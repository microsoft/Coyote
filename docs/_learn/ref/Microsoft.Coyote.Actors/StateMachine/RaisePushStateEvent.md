---
layout: reference
section: learn
title: RaisePushStateEvent
permalink: /learn/ref/Microsoft.Coyote.Actors/StateMachine/RaisePushStateEvent
---
# StateMachine.RaisePushStateEvent method (1 of 2)

Raise a special event that performs a push state operation at the end of the current action.

```csharp
protected void RaisePushStateEvent(Type state)
```

| parameter | description |
| --- | --- |
| state | Type of the state. |

## Remarks

Pushing a state does not pop the current [`State`](../StateMachineStateType), instead it pushes the specified [`State`](../StateMachineStateType) on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code:

```csharp
class Event E { }
[OnEventPushState(typeof(E), typeof(S))]
this.RaiseEvent(new E());
```

This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: [`RaiseEvent`](RaiseEvent), [`RaiseGotoStateEvent`](RaiseGotoStateEvent), [`RaisePushStateEvent`](RaisePushStateEvent) or [`RaisePopStateEvent`](RaisePopStateEvent) and [`RaiseHaltEvent`](RaiseHaltEvent). An Assert is raised if you accidentally try and do two of these operations in a single action.

## See Also

* class [StateMachine](../StateMachineType)
* namespace [Microsoft.Coyote.Actors](../StateMachineType)
* assembly [Microsoft.Coyote](../../MicrosoftCoyoteAssembly)

---

# StateMachine.RaisePushStateEvent&lt;S&gt; method (2 of 2)

Raise a special event that performs a push state operation at the end of the current action.

```csharp
protected void RaisePushStateEvent<S>()
    where S : State
```

| parameter | description |
| --- | --- |
| S | Type of the state. |

## Remarks

Pushing a state does not pop the current [`State`](../StateMachineStateType), instead it pushes the specified [`State`](../StateMachineStateType) on the active state stack so that you can have multiple active states. In this case events can be handled by all active states on the stack. This is shorthand for the following code:

```csharp
class Event E { }
[OnEventPushState(typeof(E), typeof(S))]
this.RaiseEvent(new E());
```

This event is not handled until the action that calls this method returns control back to the Coyote runtime. It is handled before any other events are dequeued from the inbox. Only one of the following can be called per action: [`RaiseEvent`](RaiseEvent), [`RaiseGotoStateEvent`](RaiseGotoStateEvent), `RaisePushStateEvent` or [`RaisePopStateEvent`](RaisePopStateEvent) and [`RaiseHaltEvent`](RaiseHaltEvent). An Assert is raised if you accidentally try and do two of these operations in a single action.

## See Also

* class [State](../StateMachineStateType)
* class [StateMachine](../StateMachineType)
* namespace [Microsoft.Coyote.Actors](../StateMachineType)
* assembly [Microsoft.Coyote](../../MicrosoftCoyoteAssembly)

<!-- DO NOT EDIT: generated by xmldocmd for Microsoft.Coyote.dll -->
